---
title: 总结状压DP——例题 P2704 [NOI2001]炮兵阵地 - Roor - 博客园
tags:
  - DP
createTime: 2025/02/14 21:31:30
permalink: /article/2i80dvhb/
---
## 题面
题目描述

司令部的将军们打算在N _M的网格地图上部署他们的炮兵部队。一个N_ M的地图由N行M列组成，地图的每一格可能是山地（用“H”
表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e199d3f39e2212ced572ce3f8a3731b4.png)

如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。
现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。

输入输出格式

输入格式：  
第一行包含两个由空格分割开的正整数，分别表示N和M；

接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。N≤100；M≤10。

输出格式：  
仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。

输入输出样例

输入样例#1：
5 4  
PHPP  
PPHH  
PPPP  
PHPP  
PHHP  
输出样例#1：
6

## 题解
看数据范围一眼状压DP。  
考虑 f[i][j][k]f[i][j][k]f[i][j][k]表示对于第i行的第j个状态且上一行的状态为第k个,本来只考虑了前两维，然后就挂了，看题解后说要三维。因为在仅考虑两维时在DP的过程中会枚举重复计算i−2的情况。
转移方程比较显然。  
DP时枚举上面两行的状态，考虑合法的进行转移即可。  
考虑预处理：  
先把 **每一行** 的合法状态都枚举出来，存起来。然后预处理前两行的f数组，因为每一行最多会对下两行有影响。


```c++
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<cstring>
    using namespace std;
    int n,m,f[105][70][70],tmp[105],sta[105][70],num[105][70],cnt[105],ans;
    int main(){
    	scanf("%d%d",&n,&m);
    	for(int i=1;i<=n;i++)
    		for(int j=1;j<=m;j++){
    			char a;scanf(" %c",&a);
    			tmp[i]<<=1;tmp[i]+=(a=='P');
    		}
    	for(int i=1;i<=n;i++)
    		for(int j=0;j<(1<<m);j++)
    			if(!(j&(j<<2))&&!(j&(j<<1))&&(j&tmp[i])==j){
    				sta[i][++cnt[i]]=j;
    				for(int k=j;k;k>>=1) num[i][cnt[i]]+=((k&1)>0);
    			}
    	for(int i=1;i<=cnt[1];i++) f[1][i][0]=num[1][i];
    	for(int i=1;i<=cnt[2];i++)
    		for(int j=1;j<=cnt[1];j++)
    			if(!(sta[2][i]&sta[1][j])) f[2][i][j]=max(f[2][i][j],f[1][j][0]+num[2][i]);
    	for(int i=3;i<=n;i++)
    		for(int j=1;j<=cnt[i];j++)
    			for(int k=1;k<=cnt[i-1];k++)
    				if(!(sta[i][j]&sta[i-1][k]))
    					for(int l=1;l<=cnt[i-2];l++)
    						if(!(sta[i][j]&sta[i-2][l])&&!(sta[i-1][k]&sta[i-2][l]))
    							f[i][j][k]=max(f[i][j][k],f[i-1][k][l]+num[i][j]);
    	for(int i=1;i<=cnt[n];i++) 
    		for(int j=1;j<=cnt[n-1];j++) ans=max(ans,f[n][i][j]);
    	printf("%d\n",ans);
    	return 0;
    }
```

以下转载自大佬的题解：  
总结一下此类题目的DP方法：若某个状态可以对下k行的状态造成影响，那么就要预处理前k行合法的，对于k+1行及以后，判断某状态是否合法需要往上枚举k行，所以dp数组要开k+1维，第一维表示行数，第二维表示现在的状态，再往后第n维表示上k-2行的状态（其实不可能出太多行的，时间指数增长）

